<!DOCTYPE html>
<html>
<head>
<style>
</style>
<script src="math.js"></script>
<script src="model.js"></script>
<script>
var triAreaUseVec = false;
var textureCorrectPerspective = true;

const black = new Vec4(0, 0, 0, 1.0);

// uvColor returns color at u,v for a debug texture in RGBA [0..1].
function uvColor(u, v) {
	let ux = Math.floor(u * 50);
	let vx = Math.floor(v * 50);
	if((ux + vx) % 2 == 1) {
		return black;
	}
	return new Vec4(u, v, 0, 1);
}

// scale RGB but not A.
function scale_rgb(v, f) {
	return new Vec4(f * v.i, f * v.j, f * v.k, v.w || 1);
}

class Texture {
	constructor(imgUrl) {
		// TODO: generate canvas instead of attaching to existing one.
		this.img = new Image();
		this.img.addEventListener("load", () => {
			const canvas = document.querySelector("#texture");
			this.W = canvas.width;
			this.H = canvas.height;

			const ctx = canvas.getContext("2d", { willReadFrequently: true });
			ctx.drawImage(this.img, 0, 0, this.W, this.H);
			this.img.style.display = "none";

			this.imageData = ctx.getImageData(0, 0, this.W, this.H).data;
		});
		this.setUrl(imgUrl);
	}

	setUrl(imgUrl) {
		this.img.crossOrigin = "anonymous";
		this.img.src = imgUrl;
	}

	// returns the color at (u,v) [0..1] in RGBA [0..255].
	get(u, v) {
		const x = Math.floor(u * this.W);
		const y = Math.floor(v * this.H);
		const off = 4 * (x + y * this.W);
		const r = this.imageData[off];
		const g = this.imageData[off+1];
		const b = this.imageData[off+2];
		const a = this.imageData[off+3];
		return new Vec4(r,g,b,a);
	}
}

class UserInput {
	constructor() {
		this.key = "";
		this.keypress = "";
		addEventListener("keydown", (ev) => { this.key = ev.code; this.keypress = ev.code; });
		addEventListener("keyup", (ev) => { this.key = ""; });
	}

	consumeKey(k) {
		if(this.keypress == k) {
			this.keypress = "";
			return true;
		}
	}
}

class Camera {
	constructor() {
		this.reset();
	}

	reset() {
		this.t = Mat4.id();
		this.zoomScale = 1.0;
		this.move(new Vec3(0, 0, -3.0));
	}

	move(p) { this.t = Mat4.translate(p.scale(-1)).mul(this.t); }
	yaw(theta) { this.t = Mat4.yaw(-theta).mul(this.t); }
	pitch(theta) { this.t = Mat4.pitch(-theta).mul(this.t); }
	roll(theta) { this.t = Mat4.roll(-theta).mul(this.t); }

	zoom(f) { this.zoomScale *= f; }

	get_transform() {
		const zoom = new Vec4(this.zoomScale, this.zoomScale, 1, 1);
		return transforms(
			this.t,
			Mat4.scales(zoom),
			Mat4.persp(),
		);
	}
}

function get_screen_transform(W, H) {
	// note: does not affect z coordinate.
	return transforms(
		Mat4.scales(new Vec3(W/2, -W/2, 1.0)),	// positive Y is up, scale X [-1,1] to [-W/2, W/2].
		Mat4.translate(new Vec3(W/2, W/2, 0)),	// translate X to [0, W].
	);
}

// Area of triangle with vertices a,b,c
function triArea(a, b, c) {
	if(triAreaUseVec) {
		b = b.vec2();
		c = c.vec2();
		const ab_perp = b.sub(a).perp();
		const ac = c.sub(b);
		return 0.5 * ab_perp.dot(ac);
	}

	// ab               = (b.i - a.i, b.j - a.j)
	// ab_perp          = (a.j - b.j, b.i - a.i)
	// ac               = (c.i - a.i, c.j - a.j)
	// ab_perp dot ac   = (a.j - b.j) * (c.i - a.i) + (b.i - a.i) * (c.j - a.j)
	return 0.5 * ((a.j - b.j) * (c.i - a.i) + (b.i - a.i) * (c.j - a.j));
}

// TriPoint represents a point in a 2D projection of a triangle.
// It allows any of the triangle properties to be interpolated from the three corners.
class TriPoint {
	constructor(tri, bary, correct_persp) {
		this.tri = tri;
		this.bary = bary;
		this.correct_persp = correct_persp;

		if(this.correct_persp) {
			this.invABCDepths = new Vec3(
				1.0 / this.tri.a.v.scrpos.k,
				1.0 / this.tri.b.v.scrpos.k,
				1.0 / this.tri.c.v.scrpos.k);
			this.depth = 1.0 / this.bary.dot(this.invABCDepths);
		} else {
			this.depth = this.bary.dot(new Vec3(
				this.tri.a.v.scrpos.k,
				this.tri.b.v.scrpos.k,
				this.tri.c.v.scrpos.k));
		}
	}

	interp(v) {
		if(this.correct_persp) {
			return this.depth * this.bary.dot(this.invABCDepths.mul(v));
		} else {
			return this.bary.dot(v);
		}
	}

	// uv returns the texture coordinates at p.
	uv() {
		// TODO: dont keep regenerating these u and v vectors, do it once for the triangle.
		const u = this.interp(new Vec3(
			this.tri.a.vt.i,
			this.tri.b.vt.i,
			this.tri.c.vt.i));
		const v = this.interp(new Vec3(
			this.tri.a.vt.j,
			this.tri.b.vt.j,
			this.tri.c.vt.j));
		return new Vec2(u, v);
	}
}

class Tri {
	constructor(a, b, c, col) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.color = col;
	}

	precompute() {
		this.visible = this.a.v.visible && this.b.v.visible && this.c.v.visible;
		if(!this.visible) {
			return
		}

		// bounding box on screen.
		const a = this.a.v.scrpos;
		const b = this.b.v.scrpos;
		const c = this.c.v.scrpos;
		this.bmin = new Vec3(
			Math.min(a.i, b.i, c.i),
			Math.min(a.j, b.j, c.j),
			Math.min(a.k, b.k, c.k),
		);
		this.bmax = new Vec3(
			Math.max(a.i, b.i, c.i),
			Math.max(a.j, b.j, c.j),
			Math.max(a.k, b.k, c.k),
		);

		// area on screen
		this.area = triArea(a, b, c);
	}

	// pointInBounds is true if p is in the triangle's screen position's bounding box.
	pointInBounds(p) {
		return (this.bmin.i <= p.i && p.i <= this.bmax.i &&
				this.bmin.j <= p.j && p.j <= this.bmax.j);
	}

	// triPoint is false if p is not in the triangle's screen position,
	// and a TriPoint if p is inside the triangle. The TriPoint has the depth
	// and allows interpolating the triangle's other properties at the point.
	triPoint(p) {
		if(!this.visible || !this.pointInBounds(p)) { return false; }

		const a = this.a.v.scrpos;
		const b = this.b.v.scrpos;
		const c = this.c.v.scrpos;
		const Wc = triArea(a, b, p);
		const Wa = triArea(b, c, p);
		const Wb = triArea(c, a, p);
		const pInside = Wa >= 0 && Wb >= 0 && Wc >= 0;
		if(!pInside) {
			return false;
		}

		const bary = new Vec3(Wa, Wb, Wc).scale(1.0 / this.area);
		return new TriPoint(this, bary, textureCorrectPerspective);
	}
}

// View is 2D view area implemented as a canvas.
// Draw updates the display by calling pixelFunc
// which maps each pixel Vec2 into a color Vec4 (RGBA, [0..255]).
// Provide a pixelFunc by subclassing and overriding, or as
// a constructor arg.
class View {
	constructor(canvasSel, pixelFunc) {
    	this.canvas = document.querySelector(canvasSel);
		if(pixelFunc) {
			this.pixelFunc = pixelFunc;
		}
		this.onResize();
	}

	onResize() {
		this.W = this.canvas.width;
		this.H = this.canvas.height;
		this.ctx = this.canvas.getContext('2d');
		this.imageData = this.ctx.getImageData(0, 0, this.W, this.H);
	}

	resize(W, H) {
		this.canvas.width = W;
		this.canvas.height = H;
		onResize();
	}

	draw() {
		const pixelData = this.imageData.data;
		var off = 0;
    	for(var y = 0; y < this.H; y++) {
        	for(var x = 0; x < this.W; x++) {
            	const p = new Vec2(x, y);
            	const color = this.pixelFunc(p);
				pixelData[off++] = color.i;
				pixelData[off++] = color.j;
				pixelData[off++] = color.k;
				pixelData[off++] = color.w || 255;
			}
		}
		this.ctx.putImageData(this.imageData, 0, 0);
	}

	// subclass+override or set view.pixelFunc
	pixelFunc(p) {
		return black.scale(255);
	}
}

// randomColor returns a random RGBA [0..1] color.
function randomColor() {
	return new Vec4(Math.random(), Math.random(), Math.random(), 1.0);
}

// TrianglesView is a view on the 2D projection of collection of triangles.
class TrianglesView extends View {
	constructor(canvasSelector, model) {
		super(canvasSelector);

		// TODO: these should be a method of some model container.
		this.yaw = 0;
		this.pitch = 0;
		this.roll = 0;
		this.trans = new Vec3(0,0,0);

		this.points = [];
		this.tris = [];
		this.plotType = "uv";

		this.points.push(...model.vs);
		model.fs.forEach(face => {
			face.forEachTriangle((a,b,c) => {
				this.tris.push(new Tri(a,b,c, randomColor()));
			});
		});
	}

	nextPlotType() {
		const next = {
			tri: "uv",
			uv: "depth",
			depth: "texture",
			texture: "tri",
		}
		this.plotType = next[this.plotType] || "tri";
	}

	// TODO: this should be a method of some model container.
	proj(tcam, tscr) {
		const transWithCam = transforms(
			Mat4.yaw(this.yaw),
			Mat4.roll(this.roll),
			Mat4.pitch(this.pitch),
			Mat4.translate(this.trans),
			tcam,
		);
		this.points.forEach(p => {
			const campos = transWithCam.mulvec(p.vec4());
			p.visible = campos.w > 0.5;
			if(p.visible) {
				p.projpos = campos.hvec4();
				p.scrpos = tscr.mulvec(p.projpos);
			}
		});

		this.tris.forEach(tri => tri.precompute());
	}

	// triAt returns the triangle point for the closest visible triangle at p.
	// TODO: this should be a method of some model container.
	triAt(p) {
		var bestDepth = Number.POSITIVE_INFINITY;
		var bestTri = false;
		for(const tri of this.tris) {
			const inTri = tri.triPoint(p);
			if(inTri !== false && inTri.depth < bestDepth) {
				bestDepth = inTri.depth;
				bestTri = inTri;
			}
		}
		return bestTri;
	}

	pixelFunc(p) {
		const trip = this.triAt(p);
		if(trip === false) {
			return black.scale(255);
		}
		g = trip;

		if(this.plotType == "depth") {
			const f = 1.0 / trip.depth;
			return new Vec3(f, f, f).scale(255);
		} else if(this.plotType == "uv") {
			const uv = trip.uv();
			return uvColor(uv.i, uv.j).scale(255);
		} else if(this.plotType == "texture") {
			const uv = trip.uv();
			return texture.get(uv.i, uv.j);
		} else {
			return scale_rgb(trip.tri.color, 1.0 / trip.depth).scale(255);
		}
	}
}
var g;

class Controller {
	constructor(statusSelector, canvasSelector, model) {
		this.status = document.querySelector(statusSelector);
		this.view = new TrianglesView(canvasSelector, model);

		this.run = true;
		this.user = new UserInput();
		this.camera = new Camera();

		this.frame = 0;
		this.reportFrame = 0;
		this.reportTs = 0;
		this.rate = 0;
		this.updateTime = 0;
		this.drawTime = 0;
		this.showHelp = 0;

		this.updateStatus();
	}

	draw() {
		const tcam = this.camera.get_transform();
		const tscr = get_screen_transform(this.view.W);
		this.view.proj(tcam, tscr);
		this.view.draw();
	}

	updateStatus() {
		var txt = `H - toggle help`;
		if(this.showHelp) {
			txt += `\nT - change plot type`;
			txt += `\n`;
			txt += `\nCamera:`;
			txt += `\nR - reset`;
			txt += `\nJ / L - turn left / right`;
			txt += `\nI / Comma - tilt up / down`;
			txt += `\nU / O - roll left / right`;
			txt += `\nW / X - move forward / backward`;
			txt += `\nA / D - move left / right`;
			txt += `\nQ / Z - move up / down`;
		} else {
			txt += `\n\ndraw type: ${this.view.plotType}`;
			txt += `\nframe rate: ${this.rate.toFixed(1)}`;

			const tot = this.updateTime + this.drawTime + 0.0001;
			const percUpdate = 100.0 * this.updateTime / tot;
			const percDraw = 100.0 * this.drawTime / tot;
			txt += `\nupdate time: ${percUpdate.toFixed(3)}%\ndraw time: ${percDraw.toFixed(1)}%`;
		}
		this.status.innerText = txt;
	}

	update() {
		this.view.yaw += deg(2);
		this.view.roll += deg(0.1);
		this.view.pitch += deg(0.2);

		if (this.user.consumeKey("KeyH")) {
			this.showHelp = !this.showHelp;
			this.updateStatus();
		};

		if (this.user.consumeKey("KeyT")) {
			this.view.nextPlotType(); 
			this.updateStatus();
		}

		if (this.user.key == "KeyR") { this.camera.reset(); };

		const speed = 0.02;
		if (this.user.key == "KeyW") { this.camera.move(new Vec3(0, 0, speed)); }; // move forward
		if (this.user.key == "KeyX") { this.camera.move(new Vec3(0, 0, -speed)); }; // move backward
		if (this.user.key == "KeyA") { this.camera.move(new Vec3(-speed, 0, 0)); }; // move left
		if (this.user.key == "KeyD") { this.camera.move(new Vec3(speed, 0, 0)); }; // move right
		if (this.user.key == "KeyQ") { this.camera.move(new Vec3(0, speed, 0)); }; // move up
		if (this.user.key == "KeyZ") { this.camera.move(new Vec3(0, -speed, 0)); }; // move down

		const angSpeed = deg(1);
		if (this.user.key == "KeyJ") { this.camera.yaw(-angSpeed); }; // look left
		if (this.user.key == "KeyL") { this.camera.yaw(angSpeed); }; // look right
		if (this.user.key == "KeyI") { this.camera.pitch(-angSpeed); }; // look up
		if (this.user.key == "Comma") { this.camera.pitch(angSpeed); }; // look down
		if (this.user.key == "KeyU") { this.camera.roll(angSpeed); }; // tilt left
		if (this.user.key == "KeyO") { this.camera.roll(-angSpeed); }; // tilt right

		const zoomSpeed = 0.01;
		if (this.user.key == "KeyS") { this.camera.zoom(1 + zoomSpeed); }; // zoom in
		if (this.user.key == "KeyK") { this.camera.zoom(1 - zoomSpeed); }; // zoom out
	}

	animate(ts) {
		const t0 = new Date().getTime();
		this.update();
		const t1 = new Date().getTime();
		this.draw();
		const t2 = new Date().getTime();

		this.frame ++;
		this.updateTime += t1 - t0;
		this.drawTime += t2 - t1;
		const dt = ts - this.reportTs;
		if(dt > 1000) {
			const alpha = 0.75;
			const dFrameDT = (this.frame - this.reportFrame) * 1000.0 / dt;
			this.rate = (1-alpha)*this.rate + alpha*dFrameDT;

			this.reportFrame = this.frame;
			this.reportTs = ts;

			this.updateTime *= 1-alpha;
			this.drawTime *= 1-alpha;

			this.updateStatus();
		}

		if(this.run) {
			requestAnimationFrame((ts) => this.animate(ts));
		}
	}
}

// TODO: this should not be a global but should be attached to each model it is related to!
const texture = new Texture("https://upload.wikimedia.org/wikipedia/commons/d/de/TestScreen_square.svg");

// global for testing from JS console.
var ui;

onload = function() {
	ui = new Controller("#status", "#draw", new Model(cube));
	//ui.run = false;
	ui.animate();
}
</script>
<style>
  #draw { position: absolute; left: 0; top: 0; }
  #status { position: absolute; left: 10; top: 0; z-index: 100; color: yellow; }
</style>
</head>
<body>
<div id="container">
<canvas id="draw" width=400 height=400></canvas>
<canvas id="texture" width=128 height=128 hidden=true></canvas>
<p id="status"></p>
</div>
</body>
</html>
