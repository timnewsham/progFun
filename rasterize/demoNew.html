<!DOCTYPE html>
<html>
<head>
<style>
</style>
<script src="math.js"></script>
<script src="model.js"></script>
<script>
var triAreaUseVec = false;
var textureCorrectPerspective = true;

const black = new Vec4(0, 0, 0, 1.0);

// uvColor returns color at u,v for a debug texture in RGBA [0..1].
function uvColor(u, v) {
	let ux = Math.floor(u * 50);
	let vx = Math.floor(v * 50);
	if((ux + vx) % 2 == 1) {
		return black;
	}
	return new Vec4(u, v, 0, 1);
}

// scale RGB but not A.
function scale_rgb(v, f) {
	return new Vec4(f * v.i, f * v.j, f * v.k, v.w || 1);
}

class Texture {
	constructor(imgUrl) {
		// TODO: generate canvas instead of attaching to existing one.
		this.img = new Image();
		this.img.addEventListener("load", () => {
			const canvas = document.querySelector("#texture");
			this.W = canvas.width;
			this.H = canvas.height;

			const ctx = canvas.getContext("2d", { willReadFrequently: true });
			ctx.drawImage(this.img, 0, 0, this.W, this.H);
			this.img.style.display = "none";

			this.imageData = ctx.getImageData(0, 0, this.W, this.H).data;
		});
		this.setUrl(imgUrl);
	}

	setUrl(imgUrl) {
		this.img.crossOrigin = "anonymous";
		this.img.src = imgUrl;
	}

	// returns the color at (u,v) [0..1] in RGBA [0..255].
	get(u, v) {
		const x = Math.floor(u * this.W);
		const y = Math.floor(v * this.H);
		const off = 4 * (x + y * this.W);
		const r = this.imageData[off];
		const g = this.imageData[off+1];
		const b = this.imageData[off+2];
		const a = this.imageData[off+3];
		return new Vec4(r,g,b,a);
	}
}

class UserInput {
	constructor() {
		this.key = "";
		this.keypress = "";
		addEventListener("keydown", (ev) => { this.key = ev.code; this.keypress = ev.code; });
		addEventListener("keyup", (ev) => { this.key = ""; });
	}

	consumeKey(k) {
		if(this.keypress == k) {
			this.keypress = "";
			return true;
		}
	}
}

class Camera {
	constructor() {
		this.t = Mat4.id();
		this.zoomScale = 1.0;

		this.move(new Vec3(0, 0, -3.0));
	}

	move(p) { this.t = Mat4.translate(p.scale(-1)).mul(this.t); }
	yaw(theta) { this.t = Mat4.yaw(-theta).mul(this.t); }
	pitch(theta) { this.t = Mat4.pitch(-theta).mul(this.t); }
	roll(theta) { this.t = Mat4.roll(-theta).mul(this.t); }

	zoom(f) { this.zoomScale *= f; }

	transform() {
		const zoom = new Vec4(this.zoomScale, this.zoomScale, 1, 1);
		return transforms(
			this.t,
			Mat4.scales(zoom),
			Mat4.persp(),
		);
	}
}

function screen_transform(W, H) {
	// note: does not affect z coordinate.
	return transforms(
		Mat4.scales(new Vec3(W/2, -W/2, 1.0)),	// positive Y is up, scale X [-1,1] to [-W/2, W/2].
		Mat4.translate(new Vec3(W/2, W/2, 0)),	// translate X to [0, W].
	);
}

// Area of triangle with vertices a,b,c
function triArea(a, b, c) {
	if(triAreaUseVec) {
		b = b.vec2();
		c = c.vec2();
		const ab_perp = b.sub(a).perp();
		const ac = c.sub(b);
		return 0.5 * ab_perp.dot(ac);
	}

	// ab               = (b.i - a.i, b.j - a.j)
	// ab_perp          = (a.j - b.j, b.i - a.i)
	// ac               = (c.i - a.i, c.j - a.j)
	// ab_perp dot ac   = (a.j - b.j) * (c.i - a.i) + (b.i - a.i) * (c.j - a.j)
	return 0.5 * ((a.j - b.j) * (c.i - a.i) + (b.i - a.i) * (c.j - a.j));
}

class TriPoint {
	constructor(tri, uvw) {
		// TODO: make this class capable of interpolating any triangle property
		// and take interpolation out of the point-in-triangle function.
		this.tri = tri;
		this.uvw = uvw;
	}
}

class Tri {
	constructor(a, b, c, col) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.color = col;
	}

	precompute() {
		this.visible = this.a.v.visible && this.b.v.visible && this.c.v.visible;
		if(!this.visible) {
			return
		}

		// bounding box on screen.
		const a = this.a.v.scrpos;
		const b = this.b.v.scrpos;
		const c = this.c.v.scrpos;
		this.bmin = new Vec3(
			Math.min(a.i, b.i, c.i),
			Math.min(a.j, b.j, c.j),
			Math.min(a.k, b.k, c.k),
		);
		this.bmax = new Vec3(
			Math.max(a.i, b.i, c.i),
			Math.max(a.j, b.j, c.j),
			Math.max(a.k, b.k, c.k),
		);

		// area on screen
		this.area = triArea(a, b, c);
	}

	// pointInBounds is true if p is in the triangle's screen position's bounding box.
	pointInBounds(p) {
		return (this.bmin.i <= p.i && p.i <= this.bmax.i &&
				this.bmin.j <= p.j && p.j <= this.bmax.j);
	}

	// pointIn is false if p is not in the triangle's screen position,
	// and true with a Vec3(texture-u, texture-v, pixel-depth) if p is inside the triangle.
	pointIn(p) {
		if(!this.visible || !this.pointInBounds(p)) { return false; }

		const a = this.a.v.scrpos;
		const b = this.b.v.scrpos;
		const c = this.c.v.scrpos;
		const Wc = triArea(a, b, p);
		const Wa = triArea(b, c, p);
		const Wb = triArea(c, a, p);
		const pInside = Wa >= 0 && Wb >= 0 && Wc >= 0;
		if(!pInside) {
			return false;
		}

		const at = this.a.vt;
		const bt = this.b.vt;
		const ct = this.c.vt;
		const bary = new Vec3(Wa, Wb, Wc).scale(1.0 / this.area);

		if(textureCorrectPerspective) {
			const m = new Mat3(
				at.i/a.k, bt.i/b.k, ct.i/c.k,
				at.j/a.k, bt.j/b.k, ct.j/c.k,
				1.0/a.k,  1.0/b.k,  1.0/c.k,
			);

			let v = m.mulvec(bary); // interploating (u/z, v/z, 1/z) at P from the three corners.
			v.i = v.i / v.k;
			v.j = v.j / v.k;
			v.k = 1.0 / v.k;
			return new TriPoint(this, v);
		} else {
			const m = new Mat3(
				at.i, bt.i, ct.i,
				at.j, bt.j, ct.j,
				a.k,  b.k,  c.k,
			);
			return new TriPoint(this, m.mulvec(bary)); // interploating (u, v, z) at P from the three corners.
		}
	}
}

// View is 2D view area implemented as a canvas.
// Draw updates the display by calling pixelFunc
// which maps each pixel Vec2 into a color Vec4 (RGBA, [0..255]).
// Provide a pixelFunc by subclassing and overriding, or as
// a constructor arg.
class View {
	constructor(canvasSel, pixelFunc) {
    	this.canvas = document.querySelector(canvasSel);
		if(pixelFunc) {
			this.pixelFunc = pixelFunc;
		}
		this.onResize();
	}

	onResize() {
		this.W = this.canvas.width;
		this.H = this.canvas.height;
		this.ctx = this.canvas.getContext('2d');
		this.imageData = this.ctx.getImageData(0, 0, this.W, this.H);
	}

	resize(W, H) {
		this.canvas.width = W;
		this.canvas.height = H;
		onResize();
	}

	draw() {
		const pixelData = this.imageData.data;
		var off = 0;
    	for(var y = 0; y < this.H; y++) {
        	for(var x = 0; x < this.W; x++) {
            	const p = new Vec2(x, y);
            	const color = this.pixelFunc(p);
				pixelData[off++] = color.i;
				pixelData[off++] = color.j;
				pixelData[off++] = color.k;
				pixelData[off++] = color.w || 255;
			}
		}
		this.ctx.putImageData(this.imageData, 0, 0);
	}

	// subclass+override or set view.pixelFunc
	pixelFunc(p) {
		return black.scale(255);
	}
}

// randomColor returns a random RGBA [0..1] color.
function randomColor() {
	return new Vec4(Math.random(), Math.random(), Math.random(), 1.0);
}

// TrianglesView is a view on the 2D projection of collection of triangles.
class TrianglesView extends View {
	constructor(canvasSelector, model) {
		super(canvasSelector);

		// TODO: these should be a method of some model container.
		this.yaw = 0;
		this.pitch = 0;
		this.roll = 0;
		this.trans = new Vec3(0,0,0);

		this.points = [];
		this.tris = [];
		this.plotType = "uv";

		this.points.push(...model.vs);
		model.fs.forEach(face => {
			face.forEachTriangle((a,b,c) => {
				this.tris.push(new Tri(a,b,c, randomColor()));
			});
		});
	}

	nextPlotType() {
		const next = {
			tri: "uv",
			uv: "depth",
			depth: "texture",
			texture: "tri",
		}
		this.plotType = next[this.plotType] || "tri";
	}

	// TODO: this should be a method of some model container.
	proj(tcam, tscr) {
		const transWithCam = transforms(
			Mat4.yaw(this.yaw),
			Mat4.roll(this.roll),
			Mat4.pitch(this.pitch),
			Mat4.translate(this.trans),
			tcam,
		);
		this.points.forEach(p => {
			const campos = transWithCam.mulvec(p.vec4());
			p.visible = campos.w > 0.5;
			if(p.visible) {
				p.projpos = campos.hvec4();
				p.scrpos = tscr.mulvec(p.projpos);
			}
		});

		this.tris.forEach(tri => tri.precompute());
	}

	// triAt returns the attributes of the closest visible triangle at p.
	// TODO: this should be a method of some model container.
	triAt(p) {
		var bestDepth = Number.POSITIVE_INFINITY;
		var bestTri = false;
		for(const tri of this.tris) {
			const inTri = tri.pointIn(p);
			if(inTri !== false && inTri.uvw.k < bestDepth) {
				bestDepth = inTri.uvw.k;
				bestTri = inTri;
			}
		}
		return bestTri;
	}

	pixelFunc(p) {
		const tri = this.triAt(p);
		if(tri === false) {
			return black.scale(255);
		}

		if(this.plotType == "depth") {
			const f = 1.0 / tri.uvw.k;
			return new Vec3(f, f, f).scale(255);
		} else if(this.plotType == "uv") {
			return uvColor(tri.uvw.i, tri.uvw.j).scale(255);
		} else if(this.plotType == "texture") {
			return texture.get(tri.uvw.i, tri.uvw.j);
		} else {
			return scale_rgb(tri.tri.color, 1 / tri.uvw.k).scale(255);
		}
	}
}

class Controller {
	constructor(statusSelector, canvasSelector, model) {
		this.status = document.querySelector(statusSelector);
		this.view = new TrianglesView(canvasSelector, model);

		this.run = true;
		this.user = new UserInput();
		this.camera = new Camera();

		this.frame = 0;
		this.reportFrame = 0;
		this.reportTs = 0;
		this.rate = 0;
		this.updateTime = 0;
		this.drawTime = 0;

		this.updateStatus();
	}

	draw() {
		const tcam = this.camera.transform();
		const tscr = screen_transform(this.view.W);
		this.view.proj(tcam, tscr);
		this.view.draw();
	}

	updateStatus() {
		const typ = `draw type: ${this.view.plotType}`;
		const r = `frame rate: ${this.rate.toFixed(1)}`;

		const tot = this.updateTime + this.drawTime + 0.0001;
		const percUpdate = 100.0 * this.updateTime / tot;
		const percDraw = 100.0 * this.drawTime / tot;
		const percs = `update time: ${percUpdate.toFixed(3)}%\ndraw time: ${percDraw.toFixed(1)}%`;

		this.status.innerText = `${typ}\n${r}\n${percs}`;
	}

	update() {
		this.view.yaw += deg(2);
		this.view.roll += deg(0.1);
		this.view.pitch += deg(0.2);

		if (this.user.consumeKey("KeyT")) {
			this.view.nextPlotType(); 
			this.updateStatus();
		}

		const speed = 0.02;
		if (this.user.key == "KeyW") { this.camera.move(new Vec3(0, 0, speed)); }; // move forward
		if (this.user.key == "KeyX") { this.camera.move(new Vec3(0, 0, -speed)); }; // move backward
		if (this.user.key == "KeyA") { this.camera.move(new Vec3(-speed, 0, 0)); }; // move left
		if (this.user.key == "KeyD") { this.camera.move(new Vec3(speed, 0, 0)); }; // move right
		if (this.user.key == "KeyQ") { this.camera.move(new Vec3(0, speed, 0)); }; // move up
		if (this.user.key == "KeyZ") { this.camera.move(new Vec3(0, -speed, 0)); }; // move down

		const angSpeed = deg(1);
		if (this.user.key == "KeyJ") { this.camera.yaw(-angSpeed); }; // look left
		if (this.user.key == "KeyL") { this.camera.yaw(angSpeed); }; // look right
		if (this.user.key == "KeyI") { this.camera.pitch(-angSpeed); }; // look up
		if (this.user.key == "Comma") { this.camera.pitch(angSpeed); }; // look down
		if (this.user.key == "KeyU") { this.camera.roll(angSpeed); }; // tilt left
		if (this.user.key == "KeyO") { this.camera.roll(-angSpeed); }; // tilt right

		const zoomSpeed = 0.01;
		if (this.user.key == "KeyS") { this.camera.zoom(1 + zoomSpeed); }; // zoom in
		if (this.user.key == "KeyK") { this.camera.zoom(1 - zoomSpeed); }; // zoom out
	}

	animate(ts) {
		const t0 = new Date().getTime();
		this.update();
		const t1 = new Date().getTime();
		this.draw();
		const t2 = new Date().getTime();

		this.frame ++;
		this.updateTime += t1 - t0;
		this.drawTime += t2 - t1;
		const dt = ts - this.reportTs;
		if(dt > 1000) {
			const alpha = 0.75;
			const dFrameDT = (this.frame - this.reportFrame) * 1000.0 / dt;
			this.rate = (1-alpha)*this.rate + alpha*dFrameDT;

			this.reportFrame = this.frame;
			this.reportTs = ts;

			this.updateTime *= 1-alpha;
			this.drawTime *= 1-alpha;

			this.updateStatus();
		}

		if(this.run) {
			requestAnimationFrame((ts) => this.animate(ts));
		}
	}
}

// TODO: this should not be a global but should be attached to each model it is related to!
const texture = new Texture("https://upload.wikimedia.org/wikipedia/commons/d/de/TestScreen_square.svg");

// global for testing from JS console.
var ui;

onload = function() {
	ui = new Controller("#status", "#draw", new Model(cube));
	//ui.run = false;
	ui.animate();
}
</script>
<style>
  #draw { position: absolute; left: 0; top: 0; }
  #status { position: absolute; left: 10; top: 0; z-index: 100; color: yellow; }
</style>
</head>
<body>
<div id="container">
<canvas id="draw" width=400 height=400></canvas>
<canvas id="texture" width=128 height=128 hidden=true></canvas>
<p id="status"></p>
</div>
</body>
</html>
