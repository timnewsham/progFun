<!DOCTYPE html>
<html>
<head>
<style>
</style>
<script src="math.js"></script>
<script src="model/cube.js"></script>
<script>
//var plotType = "depth";
//var plotType = "uv";
var plotType = "texture";
//var plotType = "triangle";
var stop = false;

function forEachPixel(W, H, f) {
    for(var y = 0; y < H; y++) {
        for(var x = 0; x < W; x++) {
            const p = new Vec2(x, y);
            f(p);
        }
    }
}

// uvColor returns color at u,v for a debug texture.
function uvColor(u, v) {
	let ux = Math.floor(u * 80);
	let vx = Math.floor(v * 80);
	if(ux % 4 == 1 || vx % 4 == 1) {
		return "black";
	}
	return new Vec3(u, v, 0).rgb();
}

class Texture {
	constructor() {
		const img = new Image();
		img.crossOrigin = "anonymous";
		img.src = "https://upload.wikimedia.org/wikipedia/commons/d/de/TestScreen_square.svg";
		img.addEventListener("load", () => {
			const canvas = document.querySelector("#texture");
			this.W = canvas.width;
			this.H = canvas.height;

			const ctx = canvas.getContext("2d", { willReadFrequently: true });
			ctx.drawImage(img, 0, 0, this.W, this.H);
			img.style.display = "none";

			this.imageData = ctx.getImageData(0, 0, this.W, this.H).data;
		});
	}

	get(u, v) {
		const x = Math.floor(u * this.W);
		const y = Math.floor(v * this.H);
		const off = 4 * (x + y * this.W);
		const r = this.imageData[off];
		const g = this.imageData[off+1];
		const b = this.imageData[off+2];
		const a = this.imageData[off+3];

		// This isnt that efficient.
		// TODO: This would be more efficient if we werent passing around rgba data as strings.
		return `rgb(${r} ${g} ${b} / ${a/255})`;
	}
}
var texture = new Texture();

class User {
	constructor() {
		this.key = "";
		addEventListener("keydown", (ev) => { this.key = ev.code; });
		addEventListener("keyup", (ev) => { this.key = "" });
	}
}

class Camera {
	constructor() {
		this.depth = 3;
		this.yaw = 0;
		this.roll = 0;
		this.pitch = 0;
	}

	transform() {
		return transforms(
			Mat4.yaw(this.yaw),
			Mat4.roll(this.roll),
			Mat4.pitch(this.pitch),
			Mat4.translate(new Vec3(0, 0, this.depth)),
			Mat4.persp(),
		);
	}
}

function screen_transform(W) {
	return transforms(
		Mat4.scales(new Vec3(W/2, -W/2, 1.0)),	// positive Y is up, scale X [-1,1] to [-W/2, W/2].
		Mat4.translate(new Vec3(W/2, W/2, 5)),	// translate X to [0, W].
	);
}

class Tri {
	constructor(a, b, c, col) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.color = col;
	}

	// computes perpendiculars to each side based on screen pos.
	precompute_sides() {
		// precomputed perpendiculars to each side.
		const a = this.a.v.scrpos.vec2();
		const b = this.b.v.scrpos.vec2();
		const c = this.c.v.scrpos.vec2();
		this.ABperp = b.sub(a).perp();
		this.BCperp = c.sub(b).perp();
		this.CAperp = a.sub(c).perp();
	}

	// computes bounding box of screen pos.
	precompute_bounds() {
		const a = this.a.v.scrpos;
		const b = this.b.v.scrpos;
		const c = this.c.v.scrpos;
		this.bmin = new Vec3(
			Math.min(a.i, b.i, c.i),
			Math.min(a.j, b.j, c.j),
			Math.min(a.k, b.k, c.k),
		);
		this.bmax = new Vec3(
			Math.max(a.i, b.i, c.i),
			Math.max(a.j, b.j, c.j),
			Math.max(a.k, b.k, c.k),
		);
	}

	// precompute sets pre-computed sides and bounds.
	precompute(dt, W, H) {
		this.visible = this.a.v.visible && this.b.v.visible && this.c.v.visible;
		if(this.visible) {
			this.precompute_bounds();
			this.precompute_sides();
		}
	}

	// pointInBounds is true if p is in the triangle's screen position's bounding box.
	pointInBounds(p) {
		return (this.bmin.i <= p.i && p.i <= this.bmax.i &&
				this.bmin.j <= p.j && p.j <= this.bmax.j);
	}

	// pointIn is false if p is not in the triangle's screen position,
	// and true with a Vec3(texture-u, texture-v, pixel-depth) if p is inside the triangle.
	pointIn(p) {
		if(!this.pointInBounds(p)) { return false; }

		const a = this.a.v.scrpos;
		const b = this.b.v.scrpos;
		const c = this.c.v.scrpos;
		const AP = p.sub(a.vec2());
		const BP = p.sub(b.vec2());
		const CP = p.sub(c.vec2());
		const ABParea = AP.dot(this.ABperp); // * 0.5, but we normalize later...
		const BCParea = BP.dot(this.BCperp);
		const CAParea = CP.dot(this.CAperp);
		const pInside = ABParea > 0 && BCParea > 0 && CAParea > 0;
		if(!pInside) {
			return false;
		}

		const at = this.a.vt;
		const bt = this.b.vt;
		const ct = this.c.vt;
		const bary = new Vec3(BCParea, CAParea, ABParea).scale(1.0 / (BCParea + CAParea + ABParea));
		const m = new Mat3(
			at.i, bt.i, ct.i,
			at.j, bt.j, ct.j,
			a.k,  b.k,  c.k,
		);

		// hrm.. the interpolation looks imperfect, ie the (u,v) along the edges of two triangles
		// that make up one cube face.
		return m.mulvec(bary); // interploating (u,v,z) at P from the three corners.
	}
}

class Data {
	constructor(m) {
		this.points = [];
		this.tris = [];

		// load all models into this.points and this.tris.
		for(const model of arguments) {
			this.points.push(...model.vs);
			model.fs.forEach(face => {
				face.forEachTriangle((a,b,c) => {
					const col = new Vec3(Math.random(), 0.8, 0.8);
					const tri = new Tri(a,b,c, col);
					this.tris.push(tri);
				});
			});
		}
	}

	proj(tcam, tscr) {
		this.points.forEach(p => {
			const campos = tcam.mulvec(p.vec4());
			p.visible = campos.w > 0.5;
			if(p.visible) {
				p.projpos = campos.hvec4();
				p.scrpos = tscr.mulvec(p.projpos);
			}
		});

		this.tris.forEach(tri => tri.precompute());
	}

	draw(canvas) {
		const ctx = canvas.getContext('2d');
    	const W = canvas.width;
    	const H = canvas.height;
		forEachPixel(W, H, p => {
			var color = "black";
			for(const tri of this.tris) {
				var bestDepth = Number.POSITIVE_INFINITY;
				if(tri.visible) {
					const inTri = tri.pointIn(p);
					if(inTri !== false && inTri.k < bestDepth) {
						bestDepth = inTri.k;
						if(plotType == "depth") {
							color = hsl(0, 0, 3.0/inTri.k);
						} else if(plotType == "uv") {
							color = uvColor(inTri.i, inTri.j);
						} else if(plotType == "texture") {
							color = texture.get(inTri.i, inTri.j);
						} else {
							color = tri.color.scale(6.0/inTri.k).hsl();;
						}
					}
				}
			}

			// TODO: This would be more efficient writing directly to the canvas ImageData.
			ctx.fillStyle = color;
			ctx.fillRect(p.i, p.j, 1, 1);
		});
	}
}

class UI {
	constructor(canvas, data) {
		this.canvas = canvas;
		this.data = data;
		this.camera = new Camera();
		this.user = new User();
	}

	draw() {
		const W = this.canvas.width;
		const H = this.canvas.height;
		const tcam = this.camera.transform();
		const tscr = screen_transform(W);
		this.data.proj(tcam, tscr);
		this.data.draw(this.canvas);
	}

	animate() {
		this.draw();

		this.camera.yaw += deg(2);
		this.camera.roll += deg(0.1);
		this.camera.pitch += deg(0.2);

		const speed = 0.05;
		if (this.user.key == "KeyI") { this.camera.depth -= speed; }
		if (this.user.key == "KeyO") { this.camera.depth += speed; }

		if(!stop) {
			requestAnimationFrame(() => this.animate());
		}
	}
}

onload = function() {
    const canvas = document.querySelector("#draw");
	const ui = new UI(canvas, new Data(cube()));
	ui.animate();
}
</script>
</head>
<body>
<canvas id="draw" width=400 height=400></canvas>
<canvas id="texture" width=128 height=128 hidden=true></canvas>
</body>
</html>
